)
knitr::opts_chunk$set(echo = TRUE)
# Install all the Packages needed
library(tidyverse)
library(broom)
library(janitor) #To clean data and turn thoese to tidy data
library(here) #To navigate through the project oriented workflow (file system)
library(ggridges) #To overlap the created plots
library(viridis) #To generate colored graphs
library(ggthemes) #To get more themes for ggplot
library(ggrepel)   #to repel overlapping text labels
library(patchwork) #To combine two or more plots together
library(ggtext) #To construct a text box
library(grid)
library(vegan)       # for Bray-Curtis distance
library(pheatmap)    # for nice dendrogram visualizations
#load concentration data with clean names
concentration_data <- clean_names(read.csv(here("data", "concentration_data.csv"))) #To read csv files in the file system here package has used and #Clean up the names of the columns according to tidydata principles
concentration_data
#loadbinary data (detect/non-detect)
binary_data <- clean_names(read.csv(here("data","binary_table.csv")))
binary_data
# Load analyte name lookup
lookup <- read.csv(here("data", "analyte_name_lookup.csv")) %>%
rename(full_name = 1, short_code = 2) %>%
mutate(short_code = tolower(short_code))  # Ensure match with cleaned names
lookup
# Step 1: Select analytes detected in ≥90% of samples
# Filter binary data based on detection percentage
# Remove sample names and the sampleType column, then select sample columns for detect percentage calculation
binary_data_matrix <- binary_data[,-1]  # Since Sample IDs are in binary data one binary data
# Calculate detection percentages
detection_percentages <- colSums(binary_data_matrix) / nrow(binary_data_matrix) * 100
detection_percentages
write.csv(detection_percentages, "detection_percentages.csv")
# Select analytes with 10% or higher detection percentage
selected_analytes <- names(detection_percentages[detection_percentages >= 80])
selected_analytes
# Step 2: Hellinger normalization
filtered_data <- concentration_data %>%
select(all_of(c("sample", "species", "basin", selected_analytes))) %>%
rowwise() %>%
mutate(total = sum(c_across(4:last_col()), na.rm = TRUE)) %>%
mutate(across(4:last_col(), ~ sqrt(. / total))) %>%  # Hellinger transformation
ungroup()
filtered_data
# Step 3: Prepare matrix for HCA
data_matrix <- filtered_data %>%
select(-species, -basin, -total) %>%
column_to_rownames("sample")
data_matrix
# Step 4: Rename columns using lookup table
original_names <- colnames(data_matrix)
mapped_names <- lookup$full_name[match(original_names, lookup$short_code)]
# Safety fallback: keep original if no match
colnames(data_matrix) <- ifelse(is.na(mapped_names), original_names, mapped_names)
# Step 5: Bray-Curtis distance
bc_dist <- vegdist(data_matrix, method = "bray")
bc_dist
# Perform hierarchical clustering (average linkage)
hclust_result <- hclust(bc_dist, method = "average")
hclust_result
# Step 6: Annotations
metadata <- filtered_data %>% select(sample, species, basin) %>% column_to_rownames("sample")
annotation_colors <- list(
species = c(
"Yellow Perch"    = "#06d6a0",
"Gizzard Shad"    = "#f7ede2",
"Freshwater Drum" = "#ef476f",
"Walleye"         = "#26547c"
),
basin = c(
"Eastern"       = "#a1c181",
"East Central"  = "#dec0f1",
"West Central"  = "#ffa69e",
"Western"       = "#42bfdd"
)
)
# ----- Heatmap Visualization with Clustering -----
# This heatmap shows both clustering and percent-normalized HPACs
# Generate the heatmap and assign it to an object
hca_pac_all_species <- pheatmap(as.matrix(data_matrix),
clustering_distance_rows = bc_dist,
clustering_method = "average",
annotation_row = metadata,
annotation_colors = annotation_colors,
show_rownames = FALSE,
show_colnames = TRUE,
scale = "none",
main = "Heatmap Created Using HCA Results (Bray-Curtis + Average Linkage)",
color = rev(viridis::inferno(100)),
silent = TRUE)  # Prevent automatic plotting
# Save it to a PNG file
png(filename = here("figures", "heatmap_all_species1.png"), width = 2000, height = 1600, res = 300)
grid::grid.newpage()
grid::grid.draw(hca_pac_all_species$gtable)  # Draw the stored heatmap plot
dev.off()
hca_pac_all_species
# Get unique species
species_list <- unique(filtered_data$species)
# Loop through each species and save heatmap
for (sp in species_list) {
cat("Creating heatmap for:", sp, "\n")
# Subset and format data for the species
species_data <- filtered_data %>%
filter(species == sp) %>%
select(-species, -basin, -total) %>%
column_to_rownames("sample")
# Rename columns using lookup
original_names <- colnames(species_data)
mapped_names <- lookup$full_name[match(original_names, lookup$short_code)]
colnames(species_data) <- ifelse(is.na(mapped_names), original_names, mapped_names)
# Compute Bray-Curtis distance
bc_dist_sp <- vegdist(species_data, method = "bray")
# Subset metadata (basin only)
metadata_sp <- filtered_data %>%
filter(species == sp) %>%
select(sample, basin) %>%
column_to_rownames("sample")
# Annotation colors
annotation_colors_filtered <- list(
basin = annotation_colors$basin
)
# Define output path (TIFF)
file_path <- here(
"figures",
paste0("Heatmap_of_", gsub(" ", "_", tolower(sp)), ".tiff")
)
# Save heatmap as TIFF
tiff(
filename = file_path,
#width = 2400,
#height = 1800,
res = 300,
compression = "lzw"
)
pheatmap(
as.matrix(species_data),
clustering_distance_rows = bc_dist_sp,
clustering_method = "average",
annotation_row = metadata_sp,
annotation_colors = annotation_colors_filtered,
show_rownames = FALSE,
show_colnames = TRUE,
scale = "none",
color = rev(viridis::inferno(100)),
legend = FALSE,              # ⬅ remove legend
fontsize = 16,
fontsize_col = 16,
fontsize_row = 14,
fontsize_annotation = 16
)
}
knitr::opts_chunk$set(echo = TRUE)
# Install all the Packages needed
library(tidyverse)
library(broom)
library(janitor) #To clean data and turn thoese to tidy data
library(here) #To navigate through the project oriented workflow (file system)
library(ggridges) #To overlap the created plots
library(viridis) #To generate colored graphs
library(ggthemes) #To get more themes for ggplot
library(ggrepel)   #to repel overlapping text labels
library(patchwork) #To combine two or more plots together
library(ggtext) #To construct a text box
library(grid)
library(vegan)       # for Bray-Curtis distance
library(pheatmap)    # for nice dendrogram visualizations
#load concentration data with clean names
concentration_data <- clean_names(read.csv(here("data", "concentration_data.csv"))) #To read csv files in the file system here package has used and #Clean up the names of the columns according to tidydata principles
concentration_data
#loadbinary data (detect/non-detect)
binary_data <- clean_names(read.csv(here("data","binary_table.csv")))
binary_data
# Load analyte name lookup
lookup <- read.csv(here("data", "analyte_name_lookup.csv")) %>%
rename(full_name = 1, short_code = 2) %>%
mutate(short_code = tolower(short_code))  # Ensure match with cleaned names
lookup
# Step 1: Select analytes detected in ≥90% of samples
# Filter binary data based on detection percentage
# Remove sample names and the sampleType column, then select sample columns for detect percentage calculation
binary_data_matrix <- binary_data[,-1]  # Since Sample IDs are in binary data one binary data
# Calculate detection percentages
detection_percentages <- colSums(binary_data_matrix) / nrow(binary_data_matrix) * 100
detection_percentages
write.csv(detection_percentages, "detection_percentages.csv")
# Select analytes with 10% or higher detection percentage
selected_analytes <- names(detection_percentages[detection_percentages >= 80])
selected_analytes
# Step 2: Hellinger normalization
filtered_data <- concentration_data %>%
select(all_of(c("sample", "species", "basin", selected_analytes))) %>%
rowwise() %>%
mutate(total = sum(c_across(4:last_col()), na.rm = TRUE)) %>%
mutate(across(4:last_col(), ~ sqrt(. / total))) %>%  # Hellinger transformation
ungroup()
filtered_data
# Step 3: Prepare matrix for HCA
data_matrix <- filtered_data %>%
select(-species, -basin, -total) %>%
column_to_rownames("sample")
data_matrix
# Step 4: Rename columns using lookup table
original_names <- colnames(data_matrix)
mapped_names <- lookup$full_name[match(original_names, lookup$short_code)]
# Safety fallback: keep original if no match
colnames(data_matrix) <- ifelse(is.na(mapped_names), original_names, mapped_names)
# Step 5: Bray-Curtis distance
bc_dist <- vegdist(data_matrix, method = "bray")
bc_dist
# Perform hierarchical clustering (average linkage)
hclust_result <- hclust(bc_dist, method = "average")
hclust_result
# Step 6: Annotations
metadata <- filtered_data %>% select(sample, species, basin) %>% column_to_rownames("sample")
annotation_colors <- list(
species = c(
"Yellow Perch"    = "#06d6a0",
"Gizzard Shad"    = "#f7ede2",
"Freshwater Drum" = "#ef476f",
"Walleye"         = "#26547c"
),
basin = c(
"Eastern"       = "#a1c181",
"East Central"  = "#dec0f1",
"West Central"  = "#ffa69e",
"Western"       = "#42bfdd"
)
)
# ----- Heatmap Visualization with Clustering -----
# This heatmap shows both clustering and percent-normalized HPACs
# Generate the heatmap and assign it to an object
hca_pac_all_species <- pheatmap(as.matrix(data_matrix),
clustering_distance_rows = bc_dist,
clustering_method = "average",
annotation_row = metadata,
annotation_colors = annotation_colors,
show_rownames = FALSE,
show_colnames = TRUE,
scale = "none",
main = "Heatmap Created Using HCA Results (Bray-Curtis + Average Linkage)",
color = rev(viridis::inferno(100)),
silent = TRUE)  # Prevent automatic plotting
# Save it to a PNG file
png(filename = here("figures", "heatmap_all_species1.png"), width = 2000, height = 1600, res = 300)
grid::grid.newpage()
grid::grid.draw(hca_pac_all_species$gtable)  # Draw the stored heatmap plot
dev.off()
hca_pac_all_species
# Get unique species
species_list <- unique(filtered_data$species)
# Loop through each species and save heatmap
for (sp in species_list) {
cat("Creating heatmap for:", sp, "\n")
# Subset and format data for the species
species_data <- filtered_data %>%
filter(species == sp) %>%
select(-species, -basin, -total) %>%
column_to_rownames("sample")
# Rename columns using lookup
original_names <- colnames(species_data)
mapped_names <- lookup$full_name[match(original_names, lookup$short_code)]
colnames(species_data) <- ifelse(is.na(mapped_names), original_names, mapped_names)
# Compute Bray-Curtis distance
bc_dist_sp <- vegdist(species_data, method = "bray")
# Subset metadata (basin only)
metadata_sp <- filtered_data %>%
filter(species == sp) %>%
select(sample, basin) %>%
column_to_rownames("sample")
# Annotation colors
annotation_colors_filtered <- list(
basin = annotation_colors$basin
)
# Define output path (TIFF)
file_path <- here(
"figures",
paste0("Heatmap_of_", gsub(" ", "_", tolower(sp)), ".tiff")
)
# Save heatmap as TIFF
tiff(
filename = file_path,
width = 2400,
height = 1800,
res = 300,
compression = "lzw"
)
pheatmap(
as.matrix(species_data),
clustering_distance_rows = bc_dist_sp,
clustering_method = "average",
annotation_row = metadata_sp,
annotation_colors = annotation_colors_filtered,
show_rownames = FALSE,
show_colnames = TRUE,
scale = "none",
color = rev(viridis::inferno(100)),
legend = FALSE,              # ⬅ remove legend
fontsize = 16,
fontsize_col = 16,
fontsize_row = 14,
fontsize_annotation = 16
)
}
knitr::opts_chunk$set(echo = TRUE)
# Install all the Packages needed
library(tidyverse)
library(broom)
library(janitor) #To clean data and turn thoese to tidy data
library(here) #To navigate through the project oriented workflow (file system)
library(ggridges) #To overlap the created plots
library(viridis) #To generate colored graphs
library(ggthemes) #To get more themes for ggplot
library(ggrepel)   #to repel overlapping text labels
library(patchwork) #To combine two or more plots together
library(ggtext) #To construct a text box
library(grid)
library(vegan)       # for Bray-Curtis distance
library(pheatmap)    # for nice dendrogram visualizations
#load concentration data with clean names
concentration_data <- clean_names(read.csv(here("data", "concentration_data.csv"))) #To read csv files in the file system here package has used and #Clean up the names of the columns according to tidydata principles
concentration_data
#loadbinary data (detect/non-detect)
binary_data <- clean_names(read.csv(here("data","binary_table.csv")))
binary_data
# Load analyte name lookup
lookup <- read.csv(here("data", "analyte_name_lookup.csv")) %>%
rename(full_name = 1, short_code = 2) %>%
mutate(short_code = tolower(short_code))  # Ensure match with cleaned names
lookup
# Step 1: Select analytes detected in ≥90% of samples
# Filter binary data based on detection percentage
# Remove sample names and the sampleType column, then select sample columns for detect percentage calculation
binary_data_matrix <- binary_data[,-1]  # Since Sample IDs are in binary data one binary data
# Calculate detection percentages
detection_percentages <- colSums(binary_data_matrix) / nrow(binary_data_matrix) * 100
detection_percentages
write.csv(detection_percentages, "detection_percentages.csv")
# Select analytes with 10% or higher detection percentage
selected_analytes <- names(detection_percentages[detection_percentages >= 80])
selected_analytes
# Step 2: Hellinger normalization
filtered_data <- concentration_data %>%
select(all_of(c("sample", "species", "basin", selected_analytes))) %>%
rowwise() %>%
mutate(total = sum(c_across(4:last_col()), na.rm = TRUE)) %>%
mutate(across(4:last_col(), ~ sqrt(. / total))) %>%  # Hellinger transformation
ungroup()
filtered_data
# Step 3: Prepare matrix for HCA
data_matrix <- filtered_data %>%
select(-species, -basin, -total) %>%
column_to_rownames("sample")
data_matrix
# Step 4: Rename columns using lookup table
original_names <- colnames(data_matrix)
mapped_names <- lookup$full_name[match(original_names, lookup$short_code)]
# Safety fallback: keep original if no match
colnames(data_matrix) <- ifelse(is.na(mapped_names), original_names, mapped_names)
# Step 5: Bray-Curtis distance
bc_dist <- vegdist(data_matrix, method = "bray")
bc_dist
# Perform hierarchical clustering (average linkage)
hclust_result <- hclust(bc_dist, method = "average")
hclust_result
# Step 6: Annotations
metadata <- filtered_data %>% select(sample, species, basin) %>% column_to_rownames("sample")
annotation_colors <- list(
species = c(
"Yellow Perch"    = "#06d6a0",
"Gizzard Shad"    = "#f7ede2",
"Freshwater Drum" = "#ef476f",
"Walleye"         = "#26547c"
),
basin = c(
"Eastern"       = "#a1c181",
"East Central"  = "#dec0f1",
"West Central"  = "#ffa69e",
"Western"       = "#42bfdd"
)
)
# ----- Heatmap Visualization with Clustering -----
# This heatmap shows both clustering and percent-normalized HPACs
# Generate the heatmap and assign it to an object
hca_pac_all_species <- pheatmap(as.matrix(data_matrix),
clustering_distance_rows = bc_dist,
clustering_method = "average",
annotation_row = metadata,
annotation_colors = annotation_colors,
show_rownames = FALSE,
show_colnames = TRUE,
scale = "none",
main = "Heatmap Created Using HCA Results (Bray-Curtis + Average Linkage)",
color = rev(viridis::inferno(100)),
silent = TRUE)  # Prevent automatic plotting
# Save it to a PNG file
png(filename = here("figures", "heatmap_all_species1.png"), width = 2000, height = 1600, res = 300)
grid::grid.newpage()
grid::grid.draw(hca_pac_all_species$gtable)  # Draw the stored heatmap plot
dev.off()
hca_pac_all_species
# Get unique species
species_list <- unique(filtered_data$species)
# Loop through each species and save heatmap
for (sp in species_list) {
cat("Creating heatmap for:", sp, "\n")
# Subset and format data for the species
species_data <- filtered_data %>%
filter(species == sp) %>%
select(-species, -basin, -total) %>%
column_to_rownames("sample")
# Rename columns using lookup
original_names <- colnames(species_data)
mapped_names <- lookup$full_name[match(original_names, lookup$short_code)]
colnames(species_data) <- ifelse(is.na(mapped_names), original_names, mapped_names)
# Compute Bray-Curtis distance
bc_dist_sp <- vegdist(species_data, method = "bray")
# Subset metadata (basin only)
metadata_sp <- filtered_data %>%
filter(species == sp) %>%
select(sample, basin) %>%
column_to_rownames("sample")
# Annotation colors
annotation_colors_filtered <- list(
basin = annotation_colors$basin
)
# Define output path (TIFF)
file_path <- here(
"figures",
paste0("Heatmap_of_", gsub(" ", "_", tolower(sp)), ".tiff")
)
# Save heatmap as TIFF
tiff(
filename = file_path,
width = 2400,
height = 1800,
res = 300,
compression = "lzw"
)
pheatmap(
as.matrix(species_data),
clustering_distance_rows = bc_dist_sp,
clustering_method = "average",
annotation_row = metadata_sp,
annotation_colors = annotation_colors_filtered,
show_rownames = FALSE,
show_colnames = TRUE,
scale = "none",
color = rev(viridis::inferno(100)),
#legend = FALSE,              # ⬅ remove legend
fontsize = 16,
fontsize_col = 16,
fontsize_row = 14,
fontsize_annotation = 16
)
}
# Get unique species
species_list <- unique(filtered_data$species)
# Loop through each species and save heatmap
for (sp in species_list) {
cat("Creating heatmap for:", sp, "\n")
# Subset and format data for the species
species_data <- filtered_data %>%
filter(species == sp) %>%
select(-species, -basin, -total) %>%
column_to_rownames("sample")
# Rename columns using lookup
original_names <- colnames(species_data)
mapped_names <- lookup$full_name[match(original_names, lookup$short_code)]
colnames(species_data) <- ifelse(is.na(mapped_names), original_names, mapped_names)
# Compute Bray-Curtis distance
bc_dist_sp <- vegdist(species_data, method = "bray")
# Subset metadata (basin only)
metadata_sp <- filtered_data %>%
filter(species == sp) %>%
select(sample, basin) %>%
column_to_rownames("sample")
# Annotation colors
annotation_colors_filtered <- list(
basin = annotation_colors$basin
)
# Define output path (TIFF)
file_path <- here(
"figures",
paste0("Heatmap_of_", gsub(" ", "_", tolower(sp)), ".tiff")
)
# Save heatmap as TIFF
tiff(
filename = file_path,
width = 2400,
height = 1800,
res = 300,
compression = "lzw"
)
pheatmap(
as.matrix(species_data),
clustering_distance_rows = bc_dist_sp,
clustering_method = "average",
annotation_row = metadata_sp,
annotation_colors = annotation_colors_filtered,
show_rownames = FALSE,
show_colnames = TRUE,
scale = "none",
color = rev(viridis::inferno(100)),
#legend = FALSE,              # ⬅ remove legend
fontsize = 16,
fontsize_col = 16,
fontsize_row = 14,
fontsize_annotation = 16
)
}
